<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>사다리 게임</title>
  <style>
    body {
      text-align: center;
      font-family: sans-serif;
    }

    canvas {
      border: 1px solid #000;
      margin-top: 20px;
    }

    input, button {
      margin: 10px;
    }

    table {
      margin: 20px auto;
      border-collapse: collapse;
      font-size: 14px;
    }

    td {
      padding: 4px 8px;
      border: none;
      text-align: left;
    }
  </style>
</head>
<body>
<h1>사다리 게임</h1>
<canvas id="ladderCanvas" width="750" height="650"></canvas>

<!-- 인원 수 선택 및 버튼 아래로 이동 -->
<div>
  <label>인원 수: <input type="number" id="playerCount" min="2" max="10" value="4"></label>
  <button onclick="drawLadder()">사다리 생성</button>
</div>

<div id="playerButtons"></div>

<!-- 결과를 테이블로 출력 -->
<table id="resultLog"></table>

<script>
  const canvas = document.getElementById('ladderCanvas');
  const ctx = canvas.getContext('2d');
  let ladderLines = [], players = [], results = [], isAnimating = false;
  let usedPlayers = new Set();

  const marginTop = canvas.height * 0.1;
  const marginBottom = canvas.height * 0.1;
  const EPSILON = 1;
  let ladderInitialized = false;
  let seededRandom = createSeededRandom(getTodaySeed());

  function createSeededRandom(seed) {
    let s = seed;
    return function () {
      s = Math.sin(s) * 10000;
      return s - Math.floor(s);
    };
  }

  function getTodaySeed() {
    const now = new Date();
    const utc = now.getTime() + now.getTimezoneOffset() * 60000;
    const koreaTime = new Date(utc + 9 * 60 * 60000); // UTC+9

    const y = koreaTime.getFullYear();
    const m = String(koreaTime.getMonth() + 1).padStart(2, '0');
    const d = String(koreaTime.getDate()).padStart(2, '0');

    return parseInt(`${y}${m}${d}`);
  }

  function getTodayDateString() {
    const now = new Date();
    const utc = now.getTime() + now.getTimezoneOffset() * 60000;
    const koreaTime = new Date(utc + 9 * 60 * 60000); // UTC+9

    const y = koreaTime.getFullYear();
    const m = String(koreaTime.getMonth() + 1).padStart(2, '0');
    const d = String(koreaTime.getDate()).padStart(2, '0');

    return `${y}-${m}-${d}`;
  }

  function drawLadder() {
    const count = parseInt(document.getElementById('playerCount').value);
    const width = canvas.width;
    const height = canvas.height;
    const colGap = width / (count + 1);
    const ladderHeight = height - marginTop - marginBottom;
    const rowGap = 20;
    const rowCount = Math.floor((ladderHeight - 20) / rowGap);
    seededRandom = createSeededRandom(getTodaySeed());

    ctx.clearRect(0, 0, width, height);
    ladderLines = [];

    for (let i = 1; i <= count; i++) {
      ctx.beginPath();
      ctx.moveTo(colGap * i, marginTop);
      ctx.lineTo(colGap * i, height - marginBottom);
      ctx.stroke();
    }

    const horizontalLinesPerGap = 5;
    for (let c = 1; c < count; c++) {
      let added = 0;
      while (added < horizontalLinesPerGap) {
        const y = Math.floor(seededRandom() * rowCount) * rowGap + marginTop + 20;

        const overlap = ladderLines.find(l =>
          Math.abs(l.y - y) < EPSILON &&
          (
            Math.abs(l.x - (colGap * (c - 1))) < EPSILON ||
            Math.abs(l.x - (colGap * c)) < EPSILON ||
            Math.abs(l.x - (colGap * (c + 1))) < EPSILON
          )
        );

        if (!overlap) {
          const x = colGap * c;
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(x + colGap, y);
          ctx.stroke();
          ladderLines.push({x, y});
          added++;
        }
      }
    }

    players = Array.from({length: count}, (_, i) => `${i + 1}등`);
    assignRoles(count);
    drawDateOverlay();
    drawTopBottomLabels(colGap);
    createPlayerButtons();
    usedPlayers.clear();
    document.getElementById('resultLog').innerHTML = '';
    ladderInitialized = true;
  }

  function drawDateOverlay() {
    // 흐릿한 오늘 날짜 텍스트 그리기
    ctx.save();
    ctx.globalAlpha = 0.08; // 투명도 낮게 설정 (0.0 ~ 1.0)
    ctx.font = 'bold 100px sans-serif';
    ctx.fillStyle = 'black';
    ctx.textAlign = 'center';
    ctx.fillText(getTodayDateString(), canvas.width / 2, canvas.height / 2);
    ctx.restore();

  }

  function drawTopBottomLabels(colGap) {
    ctx.font = '14px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle'; // 가운데 정렬로

    players.forEach((p, i) => {
      const x = colGap * (i + 1);
      ctx.fillText(p, x, marginTop - 10); // 위쪽 텍스트 위치 좀 내리기
      ctx.fillText(results[i], x, canvas.height - marginBottom + 10); // 아래 텍스트 위치 좀 올리기
    });
  }

  function createPlayerButtons() {
    const container = document.getElementById('playerButtons');
    container.innerHTML = '';
    players.forEach((p, i) => {
      const btn = document.createElement('button');
      btn.textContent = p;
      btn.onclick = () => animatePath(i);
      container.appendChild(btn);
    });

    const allBtn = document.createElement('button');
    allBtn.textContent = '전체보기';
    allBtn.onclick = () => animateAllPaths();
    container.appendChild(allBtn);
  }

  async function animateAllPaths() {
    if (!ladderInitialized || isAnimating) return;
    isAnimating = true;

    for (let i = 0; i < players.length; i++) {
      if (!usedPlayers.has(i)) {
        await animatePathAsync(i);
      }
    }

    isAnimating = false;
  }

  /**
   * 단일 등수 애니메이션을 Promise 형태로 감싸서 await 가능하게 함
   */
  function animatePathAsync(index) {
    return new Promise(resolve => {
      const colGap = canvas.width / (players.length + 1);
      const rowGap = 20;
      const rowCount = Math.floor((canvas.height - marginTop - marginBottom) / rowGap);
      let col = index;
      let x = colGap * (col + 1);
      let y = marginTop;

      const path = [{x, y}];

      for (let r = 0; r < rowCount; r++) {
        y += rowGap;
        let curX = colGap * (col + 1);

        const right = ladderLines.find(line =>
          Math.abs(line.x - curX) < EPSILON && Math.abs(line.y - (y - rowGap)) < EPSILON
        );
        const left = ladderLines.find(line =>
          Math.abs(line.x - (curX - colGap)) < EPSILON && Math.abs(line.y - (y - rowGap)) < EPSILON
        );

        if (right) {
          path.push({x: curX + colGap, y: y - rowGap});
          path.push({x: curX + colGap, y});
          col++;
        } else if (left) {
          path.push({x: curX - colGap, y: y - rowGap});
          path.push({x: curX - colGap, y});
          col--;
        }

        path.push({x: colGap * (col + 1), y});
      }

      drawLadderBaseOnly();
      ctx.strokeStyle = 'red';
      ctx.lineWidth = 2;

      let i = 0;

      function step() {
        if (i >= path.length - 1) {
          ctx.strokeStyle = 'black';
          ctx.lineWidth = 1;
          usedPlayers.add(index);
          logResult(index, col);
          resolve(); // 다음 등수로 진행
          return;
        }
        ctx.beginPath();
        ctx.moveTo(path[i].x, path[i].y);
        ctx.lineTo(path[i + 1].x, path[i + 1].y);
        ctx.stroke();
        i++;
        requestAnimationFrame(step);
      }

      step();
    });
  }

  function assignRoles(count) {
    const mafia = Math.floor(count / 4);
    const citizen = mafia * 3;
    const trash = count - (mafia + citizen);
    results = [
      ...Array(mafia).fill('마피아'),
      ...Array(citizen).fill('시민'),
      ...Array(trash).fill('꽝')
    ];
    results.sort(() => seededRandom() - 0.5);
  }

  function animatePath(index) {
    if (!ladderInitialized || isAnimating || usedPlayers.has(index)) return;
    isAnimating = true;
    usedPlayers.add(index);

    const colGap = canvas.width / (players.length + 1);
    const rowGap = 20;
    const rowCount = Math.floor((canvas.height - marginTop - marginBottom) / rowGap);
    let col = index;
    let x = colGap * (col + 1);
    let y = marginTop;

    const path = [{x, y}];

    for (let r = 0; r < rowCount; r++) {
      y += rowGap;
      let curX = colGap * (col + 1);

      const right = ladderLines.find(line =>
        Math.abs(line.x - curX) < EPSILON && Math.abs(line.y - (y - rowGap)) < EPSILON
      );
      const left = ladderLines.find(line =>
        Math.abs(line.x - (curX - colGap)) < EPSILON && Math.abs(line.y - (y - rowGap)) < EPSILON
      );

      if (right) {
        path.push({x: curX + colGap, y: y - rowGap});
        path.push({x: curX + colGap, y});
        col++;
      } else if (left) {
        path.push({x: curX - colGap, y: y - rowGap});
        path.push({x: curX - colGap, y});
        col--;
      }

      path.push({x: colGap * (col + 1), y});
    }

    drawLadderBaseOnly();
    ctx.strokeStyle = 'red';
    ctx.lineWidth = 2;

    let i = 0;

    function step() {
      if (i >= path.length - 1) {
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 1;
        isAnimating = false;
        logResult(index, col);
        return;
      }
      ctx.beginPath();
      ctx.moveTo(path[i].x, path[i].y);
      ctx.lineTo(path[i + 1].x, path[i + 1].y);
      ctx.stroke();
      i++;
      requestAnimationFrame(step);
    }

    step();
  }

  function drawLadderBaseOnly() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const count = players.length;
    const colGap = canvas.width / (count + 1);
    const height = canvas.height;

    for (let i = 1; i <= count; i++) {
      ctx.beginPath();
      ctx.moveTo(colGap * i, marginTop);
      ctx.lineTo(colGap * i, height - marginBottom);
      ctx.stroke();
    }

    ladderLines.forEach(({x, y}) => {
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x + colGap, y);
      ctx.stroke();
    });
    drawDateOverlay();
    drawTopBottomLabels(colGap);
  }

  function logResult(startIdx, endIdx) {
    const table = document.getElementById('resultLog');
    const row = document.createElement('tr');
    row.innerHTML = `<td>${players[startIdx]}</td><td>→</td><td>${results[endIdx]}</td>`;
    table.appendChild(row);

    const rows = Array.from(table.rows);
    rows.sort((a, b) => {
      const numA = parseInt(a.cells[0].textContent);
      const numB = parseInt(b.cells[0].textContent);
      return numA - numB;
    });

    table.innerHTML = '';
    rows.forEach(r => table.appendChild(r));
  }
</script>
</body>
</html>
